
------------------------------------------------------------------------------
-- Program Name: Colorite
-- This 1280 custom made program '
------------------------------------------------------------------------------

program Colorite; 
 
#include colorite.iri 

  -- Constants and aliases definitions 
  g_csProgName          : constant string  := "Colorite"; --Program Name 
  g_csVersion           : constant string  := "1.00"; --Program Version   
  --g_ciPrinter           : constant integer := 0;
  g_ciPort1             : constant integer := 1;
  g_ciPort2             : constant integer := 2;
  g_ciDigInOn           : constant integer := 0; --Digital Input is On 
  g_ciDigInOff          : constant integer := 1; --Digital Input is Off
  g_ciDigOutOn          : constant integer := 1; --Digital Output is On
  g_ciDigOutOff         : constant integer := 0; --Digital Output is Off  
  g_ciBackDoorPassword  : constant string  := "asc1058";  --Backdoor Password 

  
  -- Inputs/Outputs  
  --g_coUnder   : constant integer := 1;
  --g_coAccept  : constant integer := 2;  
  --g_coOver    : constant integer := 3;

  -- Screens
  g_ciMainLogin    : constant integer := 1;
  g_ciScanBar      : constant integer := 2;
  g_ciStatus       : constant integer := 3;
  g_ciSearching    : constant integer := 4;
  g_ciSetUpUsers   : constant integer := 5;
  g_ciOrderNum     : constant integer := 6;



  -- Operation Modes
  LockMode                : constant integer := 0;
  NoMode                  : constant integer := 100;    
  EnterItemID             : constant integer := 101; 
  GetID                   : constant integer := 102;
  ProductOnScale          : constant integer := 103;
  
  -- Setup Modes
  --SetupEnterPasswordMode   : constant integer := 999;
  --Setup1Mode               : constant integer := 1000; 
  --SetupChangePasswordMode  : constant integer := 1100;
  --SetupVerifyPasswordMode  : constant integer := 1101; 
  --SetupItemId               : constant integer := 1210;
  --SetupItemName             : constant integer := 1211;
  --SetupItemLowWeight        : constant integer := 1212;
  --SetupItemHighWeight       : constant integer := 1213;               
  --SetupDeleteItem         : constant integer := 1220;
  --SetupClearTransactions  : constant integer := 1230;
  --SetupThresholdWeight    : constant integer := 1300;
  -- SendingPCTest           : constant integer := 1400;
  --Setup2Mode               : constant integer := 2000; 
   

  --New Modes ARIS
  EntryMode         : integer;
  g_EntryMode       : integer;
  ScanMode          : constant integer := 1000;
  LoginMode         : constant integer := 1001;
  SetOrderNumMode   : constant integer := 1002;
  UserIdMode        : constant integer := 1003;
  PasswordMode      : constant integer := 1004;
  NewPasswordMode   : constant integer := 1005;
  NewUserMode       : constant integer := 1006;
  SetupMenuMode     : constant integer := 1007;
  AdminPasswordMode : constant integer := 1008;
  ProcessNewUser    : constant integer := 1009;
  ScannedItemMode   : constant integer := 1010;
  OrderMode         : constant integer := 1011;
  StatusMode        : constant integer := 1012;
  GetBagsMode       : constant integer := 1013;
  AddScanMode       : constant integer := 1014;
  

  Blank : constant string := "";      
  type boolean is (False,True); 

  -- Global/Types variables definitions

  --New ARIS
  g_sUserId :stored string;
  g_sPassword: stored string;
  --g_sTempPass: stored string;
  g_sTUser : stored string; 
  g_sTPass : stored string;
  g_sScannerInput : string; 
  g_ciDebug: constant integer := 0;
  g_bLogin: stored boolean;
  g_sOrderNum : stored string;
  g_sTempScanned : string;
  g_sItemId   :string;
  g_sItemLot  : string;
  g_sItemWeight : string;
  g_rItemWeight : stored real;
  g_sPounds : string;
  g_sOunces : string;
  g_rPounds : stored real;
  g_rOunces : stored real;
  g_iBags   : integer;
  g_iNums   : integer;

  locked : boolean := True;

---- Previous global variables from Checkweight Program
  g_sSetupPassword : stored string;
  g_iDownload : stored integer;
  g_sTmpPassword : string;  
  g_rCountby : real;    
  g_bUpdate : boolean;
  g_iDecimal1 : integer;  
  g_uUnits : Units;
  g_sysResult : SysCode; 
  g_sysResult1 : SysCode; 
  g_sysResult2 : SysCode;  
  g_iDebug : integer;
  --g_sItemId : stored string;   
  g_sItemName : stored string;  
  g_rLowWeight : stored real;
  g_rHighWeight : stored real;     
  g_iAutoPrint : stored real;
  g_rThresholdWeight : stored real;
  g_bWeighVault : stored boolean;
  g_iWidget : integer;
  g_iTareAttempt : integer;
  g_rTareWgt : stored real;
  g_spcResponseBuffer : string;
  g_sUnits : stored string;
  g_rTargetWgt : stored real;
  g_rLastSavedWgt : real;
  g_bPrintPressed : boolean;


  
  --DATABASES AND ARRAYS
  type UserArrays is array [1000] of string; 
  
  UsersDB  :UsersDatabase;  
  OrdersDB :OrdersDatabase;

  type Barcode is array [40] of string;



-- keep
  procedure SetupStartTimer(iTimer : integer; iDuration : integer; itmMode : TimerMode);  -- Setup a Timer and Start                                
  begin
  
    SetTimer(iTimer, iDuration);
    SetTimerMode(iTimer, itmMode);
    StartTimer(iTimer);
    
  end;     
  
  procedure PromptForEntry(sPrompt : string;  iMode : integer; sDefault : string; iType : integer);  -- Prompts operator for data
  begin
    
    DisableHandler(NumericKeyPressed);
    DisableHandler(EnterKeyPressed);
    DisableHandler(NavUpKeyPressed);
    DisableHandler(NavDownKeyPressed);   
    
    --LockMajorKeys;
 
		SetEntry(sDefault);
    if iType = 0 then
      PromptUser(sPrompt);
    elsif iType = 1 then  
      PromptPassword(sPrompt);
    elsif iType = 2 then
      PromptNumeric(sPrompt);
    end if;
    g_EntryMode := iMode;
    
  end;  

--  procedure DisableSetPoints;
-- begin
    
--    DisableSP(1);
--    DisableSP(2);
    
--  end;

  function GetCurrentUnitsString(s : integer) : string;  -- Gets current units string (lb/kg/etc). 
    sUnit : Units;
    sUnitString : string;  
  begin          
    
    if GetUnits(s, sUnit) = SysOk then
      GetUnitsString(s, sUnit, sUnitString);    
    else
      sUnitString := Blank;
    end if; 
    
    return sUnitString; 
    
  end;    

  procedure PrintTicket; 
		sUnits : string;
  begin  

    sUnits := GetCurrentUnitsString(1);    

		--SetPrintText(1, TransDB.ItemId);
		--SetPrintText(2, TransDB.ItemName);
		--SetPrintText(3, RealToString(TransDB.Weight,0,g_iDecimal1) + " " + sUnits);
		--SetPrintText(4, TransDB.Status);
		--SetPrintText(5, Date$(TransDB.DT));
		--SetPrintText(6, Time$(TransDB.DT));
		Print(AuxFmt1);
  end;     

  procedure LockMajorKeys;  -- Locks ZERO, GROSS/NET, TARE, UNITS and PRINT key
  begin
  
    LockKey(GrossNetKey);
    LockKey(TareKey);
    LockKey(UnitsKey);
    LockKey(PrintKey);
    
  end; 

  procedure UnLockMajorKeys;  -- UnLocks ZERO, GROSS/NET, TARE, UNITS and PRINT key
  begin
  
    UnlockKey(GrossNetKey);
    UnlockKey(TareKey);
    UnlockKey(UnitsKey);
    UnlockKey(PrintKey);
    
  end;   

  procedure LockAllKeys; -- Lock All Keys
  begin
    LockMajorKeys;
  end;
  

procedure ClearLoginUser; 
begin
  g_sUserId := Blank;
  g_sPassword := Blank;
end;

procedure  ClearNewUserVars; 
begin
  g_sTUser := Blank;
  g_sTPass := Blank;
end;

procedure ClearWidgetsLogin; --clears widgets for LOGIN PAGE
begin
  SetLabelText(lbl18, Blank);
  SetLabelText(lbl19, Blank);
end;

procedure ClearWidgetsNewUser; --ckears widgets for NEW USER PAGE
begin
  SetLabelText(lbl24, Blank);
  SetLabelText(lbl25, Blank);
end;

procedure AddNewUser;
begin
    UsersDB.login := g_sTUser; -- we are temporarily setting the value of g_sTUser to the database 
    UsersDB.password := g_sTPass;

    g_sysResult := UsersDB.FindFirst(Users_login);
    if g_sysResult <> SysOk then
      UsersDB.Add;
      ClearWidgetsNewUser;
      ClearNewUserVars;
      DisplayStatus("New User Added");
      EntryMode := AdminPasswordMode;
      SetWidgetVisibility(AddUser, Voff);
    else
      DisplayStatus("ERROR: User Exists -- Proceed to Login Page");
      --EntryMode := NoMode;
    end if;

end;

procedure ProcessingLoginEntry;
begin
    g_bLogin := False;
    UsersDB.login := g_sUserId; -- we are temporarily setting the value of g_sUsedId to the database 
    UsersDB.password := g_sPassword;

    g_sysResult := UsersDB.FindFirst(Users_login); --This will equal SysOk if found in DB
    if g_sysResult = SysOk then
      g_bLogin := True;
      if g_bLogin = True then
        SelectScreen(g_ciOrderNum);
        EntryMode := OrderMode;
        --SetWidgetVisibility(lbl8, Voff);
        --SetWidgetVisibility(lbl31, Voff);
        
      end if;
    else
      DisplayStatus("Incorrect Credentials. Please try again.");
      ClearLoginUser;
      ClearWidgetsLogin;
      EntryMode := LoginMode;  
    end if;
  
end;

--keep/revise
  --function IsDigits(sNumeric : string) : boolean;  -- Makes ure user entry is numeric       
    --i : integer;
    --sTemp : string;
    --bResult : boolean := True;
    --bDecimal : boolean := False;
  --begin
  
    --if sNumeric = "." or StringToInteger(sNumeric) >= g_ciInt32_Max then   
      --bResult := False;
      --return bResult;
    --end if;  

    --for i := 1 to Len(sNumeric)
    --loop                              
    
      --sTemp := Mid$(sNumeric, i, 1); 
      
      -- ignore first decimal point
      --if sTemp = "." then  
        --if bDecimal = True then   
          --bResult := False;
          --exit;   
        --end if;     
        --bDecimal := True;  
      --end if; 
      
      -- ignore negative if first character
      --if i <> 1 and sTemp = "-" then
        --bResult := False;
        --exit;
      --end if;
      
      --if (sTemp < "0" or sTemp > "9") and sTemp <> "." and sTemp <> "-" then        
        --bResult := False;
        --exit;
      --end if; 
      
    --end loop;
        
    --return bResult; 
    
  --end;   


--keep/revise
  function IsValid(sTemp : string; sValidFor : string; iLength : integer) : boolean;  -- Validates a String, Integer and Real
    bResult : boolean := True; 
    sMessage : string;
  begin 
    
    sValidFor := UCase$(sValidFor);
    
    if sValidFor = "S" then
    
      if Len(sTemp) = 0 or (Len(sTemp) > iLength and iLength <> 0) then  
        bResult := False;
        sMessage := "Required Entry - Try Again";  
      end if;      
        
    --elsif sValidFor = "I" then
      
      --if isDigits(sTemp) = False then
        --bResult := False;  
        --sMessage := "Invalid Number - Try Again";        
      --elsif (Len(sTemp) = 0 or StringToInteger(sTemp) < 1) and iLength = 0 then   -- iLength to 1 will allow zero for an entry
        --bResult := False;  
        --sMessage := "Invalid Number (0) - Try Again";
      --end if;      
    
    --elsif sValidFor = "R" then
    
      --if isDigits(sTemp) = False or StringToReal(sTemp) < 0 then     
        --bResult := False;    
        --sMessage := "Invalid Number - Try Again";
      --elsif (Len(sTemp) = 0 or StringToReal(sTemp) = 0) and iLength = 0 then  -- iLength to 1 will allow zero for an entry
        --bResult := False;    
        --sMessage := "Invalid Number (0) - Try Again";              
      --end if;  

    --elsif sValidFor = "P" then
    
      --if isDigits(sTemp) = False or StringToReal(sTemp) < 0 or StringToReal(sTemp) > 100 then 
        --bResult := False; 
        --sMessage := "Invalid Number (0-100) - Try Again";
      --end if; 
                
    else
      
      DisplayStatus("Validation Error");
      bResult := False;
      
    end if;

    if bResult = False then
      if sValidFor = "P" or sValidFor = "R" or sValidFor = "I" then
        PromptForEntry(sMessage, EntryMode, Blank,2);
      else  
        PromptForEntry(sMessage, EntryMode, Blank, 0);
      end if;
    end if;
    
    return bResult;

  end;  


--  function GetMilitaryTime (dtTemp : datetime) : string;   -- Military time
--    iHour: integer;
--    iMin : integer;
--    iSec : integer;
--    sHour : string;
--    sMin : string;  
--    sSec : string;
--    s24HourTime : string;  
--  begin  
  
--    GetTime(dtTemp, iHour, iMin, iSec); 
    
--    sHour := IntegerToString(iHour,0);
--    if Len(sHour) = 1 then
--      sHour := "0" + IntegerToString(iHour,0);
--    end if; 
--    sMin := IntegerToString(iMin,0);  
--    if Len(sMin) = 1 then
--      sMin := "0" + IntegerToString(iMin,0);
--    end if;
--    sSec := IntegerToString(iSec,0);  
--    if Len(sSec) = 1 then
--      sSec := "0" + IntegerToString(iSec,0);
--    end if;

--    s24HourTime := sHour + sMin + sSec;  
--    return s24HourTime; 
  
--  end; 

--KEEP
  function GetFormattedDate (dtTemp : datetime) : string; -- Format Date DDMMYYYY 
    iYear : integer;
    iMonth : integer;
    iDay : integer; 
    sDay : string;
    sFormattedDate : string := BLANK;  
    tmpDate : datetime; 
  begin
    
    GetDate(dtTemp, iyear, imonth, iday);  
    
    -- Configure month
    if iday < 10 then                   
      sDay := "0" + IntegerToString(iDay,0);
    else
      sDay := IntegerToString(iDay,0); 
    end if;  

    sFormattedDate := sDay;         
    
    -- Configure Day
    if iMonth < 10 then                   
      sFormattedDate := sFormattedDate + "0" + IntegerToString(iMonth,0) ;
    else
      sFormattedDate := sFormattedDate + IntegerToString(iMonth,0); 
    end if;
    
    -- configure Year 
    if iyear < 10 then
      sFormattedDate := sFormattedDate + "200" + IntegerToString(iyear,0);  
    else   
      sFormattedDate := sFormattedDate + "20" + IntegerToString(iyear,0);   
    end if;
    
    --sFormattedDate := sFormattedDate + " " + GetMilitaryTime(dtTemp);
    
    return sFormattedDate; 

  end; 


  --KEEP     
  -- Returns the starting location in "input_string" of
  -- the first occurance of the string "match_string"
  function Locate( input_string : string;
                   match_string : string ) : integer;

    position     : integer;
    end_position : integer;


    begin

      position := 1;
      end_position := Len(input_string) + 1 - Len(match_string) ;

      while position <= end_position
      loop
        if match_string = Mid$(input_string, position, Len(match_string)) then
          return position;
        end if;
        position := position + 1;
      end loop;
      return 0;
  end;
        
  --keep      
  -- This function is used to trim "n" characters off a string.
  function TrimNum$( var input_string : string;
                     trim_length      : integer ) : string;

    result : string;

    begin
      if trim_length > 0 then
        result       := Left$(input_string, trim_length);
        input_string := Right$(input_string, Len(input_string)-trim_length);

      elsif trim_length < 0 then
        result       := Right$(input_string, -trim_length);
        input_string := Left$(input_string, Len(input_string)+trim_length);
      else
        result       := "";
      end if;
      return result;
  end;

--KEEP
  --  Strips off all leading occurances in "input_string" of any characters in the string "trim_chars".
  function TrimLeft$( input_string : string;
                      trim_chars   : string ) : string;

    result   : string;
    position : integer := 1;

    begin

      while (position <= Len(input_string))
      loop


        -- If the current character is not in the trim list
        if ( Locate(trim_chars, Mid$(input_string, position, 1)) = 0 ) then

          -- return remainder of input string
          result := Mid$(input_string, position, Len(input_string));
          return result;

        end if;

        position := position + 1;


      end loop;

      return "";

  end;   


  --  This function is used to parse a single string from
  --  a passed string using a passed parse character
  function ParseLeft$( var input_string : string;
                       parse_char       : string ) : string;

    result   : string;
    position : integer;

    begin

      -- If blank delimited, remove all leading blanks
      if parse_char = " " then
        input_string := TrimLeft$(input_string, " ");
      end if;


      -- Find first occurance of parse character(s)
      position := Locate(input_string, parse_char);


      -- If one is present...
      if (position > 0) then

        -- Set result = parsed off characters
        result := TrimNum$(input_string, position-1);

        -- If blank delimited, remove all leading blanks
        if parse_char = " " then
          input_string := TrimLeft$(input_string, " ");

        -- Otherwise, remove one occurance of parse character(s)
        else
          TrimNum$(input_string, Len(parse_char));

        end if;


      -- If no parse character found, result = entire input string
      else
        result := input_string;
        input_string := "";
      end if;


      return result;
  end;   
  
  function CalcDecimal(rCountBy : real) : integer;  -- Calculates the amount of decimal positions  
    iDecimal : integer := 0;    
  begin   
         
    while rCountBy < 1.0
    loop    
      iDecimal := iDecimal + 1;
      rCountBy := rCountBy * 10.0;  
     end loop;

     return iDecimal; 
     
  end; 


  procedure DisplayVersion;    -- Displays Version Number and program name on startup or exiting config   
  begin   
  
    DisplayStatus(g_csProgName + " " + g_csVersion); 
    --SetLabelText(lbProg, "Program: " + g_csProgName + " " + g_csVersion);  
    
  end; 

  --procedure TurnOffAllOutputs;  -- Turn off All Outputs
    --i : integer;
  --begin
    
    --for i := 1 to 3
    --loop
      --SetDigout(0, i, g_ciDigOutOff);
    --end loop;  
  
  --end;     

--KEEP AND REVISE
  procedure TurnOffWidgets;
  begin

    SetwidgetColor(1, "#F0EEEE");
    --SetLabelText(lbSts1, Blank);
		--SetLabelText(lbAOU, Blank);	

  end;
  

  procedure RefreshSetupDisplay;  -- Update display screen in setup menu 
    sUnits : string;    
		sPassword : string;
		i : integer;
  begin          

		for i := 1 to Len(g_sSetupPassword)
		loop
			sPassword := sPassword + "*";
		end loop;  

    sUnits := GetCurrentUnitsString(1);     

    --SetLabelText(lbSet1, "Setup Password ");
    --Setlabeltext(lbSet11, sPassword);          
    --SetLabelText(lbSet2, "Threshold Weight ");
    --setlabeltext(lbSet22, RealToString(g_rThresholdWeight,0,g_iDecimal1) + " " + sUnits);  
    --if g_iAutoPrint = 1 then
      --SetLabelText(lbSet3, "Auto Print: ON");   
    --else
      --SetLabelText(lbSet3, "Auto Print: OFF");  
    --end if;
    --SetLabelText(lbSet4, "Clear Transactions");
		--SetLabelText(lbSet5, "Add/Edit Items");
    --SetLabelText(lbSet6, "Delete Items");
    --SetLabelText(lbSet7, "Import / Export");
    --Setlabeltext(lbSet8, "CW-90 WeighVault");
    --if g_bWeighVault = True then
      --SetLabelText(lbSet88, "Enabled");
    --else
      --SetLabelText(lbSet88, "Disabled");
    --end if;
    --SetLabelText(lbSet9, "WeighVault");
    --SetlabelTExt(lbSet99, "PC Test");		
  end; 
  
  procedure RefreshMainDisplay; 
    sUnits : string;      
  begin
		
		if g_sItemId <> Blank then
    	sUnits := GetCurrentUnitsString(CurrentScale);
    	--SetLabelText(lbId2, g_sItemId + " " +  g_sItemName); 
    	--SetLabelText(lbLow, RealToString(g_rLowWeight,0,g_iDecimal1) + " " + sUnits);      
    	--SetLabelText(lbHigh, RealToString(g_rHighWeight,0,g_iDecimal1) + " " + sUnits);
		
		--else
    	--SetLabelText(lbId2, Blank); 
    	--SetLabelText(lbLow, Blank);      
    	--SetLabelText(lbHigh, "");
		end if;
  
  end;

  --procedure SetupScreens;
  --i : integer;
  --begin
    --SetBargraphLevel(barSet1, 100);
    --SetBargraphLevel(barSet2, 100);
    --SetBargraphLevel(barSet3, 100);
    --SetBargraphLevel(barSet4, 100);
    --SetBargraphLevel(barSet5, 100);
    --SetBargraphLevel(barSet6, 100);
    --SetBargraphLevel(barSet7, 100);
    --SetBargraphLevel(barSet8, 100);
    --SetBargraphLevel(barSet9, 100);
    --SetBargraphLevel(barSet10, 100);
    --SetBargraphLevel(barSet12, 100);
    --SetBargraphLevel(barSet13, 100);

  --end;

  procedure ToggleOutput(iOUtput : integer);
    iDigOutSts : integer;
  begin

    GetDigOut(0, iOutput, iDigOutSts);
    if iDigOutSts = g_ciDigOutOn then
      SetDigOut(0, iOutput, g_ciDigOutOff);
    else
      SetDigOut(0, iOutput, g_ciDigOutOn);
    end if;

  end; 
  
  procedure GoIntoSetupMenu;  -- Enters Setup Menu
  begin
 
    --DisableSetPoints;
    DisplayStatus("Setup Menu");
    --EntryMode := Setup1Mode;    
    --SelectScreen(g_ciSetup);     
    RefreshSetupDisplay;     
  
  end; 

  procedure ClearStatus(iTime : integer);  -- Removes Display Status Message
  begin
    SetupStartTimer(29, iTime, TimerOneShot);
  end;  

 procedure GetLotandWeight(tempScan :string);
    tempI : integer;
    tempS : string;
    finalLot : string := "";
    finalWeight : string;
		i			: integer;	
    temp1 : string;
 begin
    tempI := Len(tempScan);
    for i := 1 to tempI	 
    loop
      -- take the first letter of the string
      temp1 := Left$(tempScan, 1);
      tempScan := Right$( tempScan, tempI-i);
      if temp1 <> Chr$(96) then
        finalLot := finalLot + temp1;
      elsif temp1 = Chr$(96) then
        finalWeight := tempScan;
        exit;
      end if;
    end loop;
    --DisplayStatus(finalWeight);
    g_sItemLot := finalLot;
    g_sItemWeight := finalWeight;
    g_rItemWeight := StringToReal(finalWeight);

 end;

procedure processingWeight;
  tempI : integer;
  tempS : string;
  i : integer;
  temp1 : string;
  temp_weight : string;
  final_pounds : string;
  final_ounces : string;
  begin
    temp_weight := g_sItemWeight;
    tempI := len(temp_weight);
    for i := 1 to tempI
    loop
    -- taking first number in string
    temp1 := Left$(temp_weight, 1);
    temp_weight := Right$(temp_weight, tempI - i);

    if temp1 <> Chr$(46) then
      final_pounds := final_pounds + temp1;
    
    elsif temp1 = Chr$(46) then
      final_ounces := temp_weight;
    exit;
    end if;
  
  end loop;
  g_sPounds := final_pounds;
  g_rPounds := StringToReal(final_pounds);
	
	
  --DisplayStatus(final_pounds);
  g_sOunces := final_ounces;
  g_rOunces := StringToReal(g_sOunces);

-- calculation for ounces
  g_rOunces := (g_rOunces / 10) * 16;
  
  g_sOunces := RealToString(g_rOunces, 1, 2);

  --DisplayStatus(g_rOunces);

  --DisplayStatus(final_ounces);
	
  end;

  
  
  --procedure ProcessDataEntry(sTemp : string);  -- Processing the entered data  
  --begin 
    
    --ClosePrompt;   
    --UnLockMajorKeys;
    
    --if EntryMode = SetupChangePasswordMode then
     
        --g_sTmpPassword := sTemp;
        --PromptForEntry("Re-enter Password to Verify", SetupVerifyPasswordMode, Blank,0);        
     
    --elsif EntryMode = SetupVerifyPasswordMode then 
    
      --if sTemp = g_sTmpPassword then    
        --g_sSetupPassword := sTemp;
        --EntryMode := Setup1Mode;
        --DisplayStatus("Password Changed");      
      --else 
        --DisplayStatus("Error: Passwords don't Match");
        --EntryMode := Setup1Mode;  
      --end if;
    
    --elsif Entrymode = SetupEnterPasswordMode then

      --g_sTmpPassword := sTemp;
      --if g_sTmpPassword = g_sSetupPassword or g_sTmpPassword = g_ciBackDoorPassword then  
        --GoIntoSetupMenu;          
      --else      
        --DisplayStatus("Error: Invalid Password");   
        --g_sTmpPassword := Blank;        
        --EntryMode := NoMode;                         
      --end if;    

		--elsif EntryMode = SetupThresholdWeight then
      --if IsValid(stemp, "r", 1) then
        --g_rThresholdWeight := StringToReal(sTemp);  
    		--SetSPValue(1, g_rThresholdWeight);
    		--SetSPValue(2, g_rThresholdWeight);  
				--EntryMode := Setup1Mode;
      --end if;   

    --elsif EntryMode = SetupItemId then
      --if IsValid(stemp, "s", 15) then
        --ItemDB.Id  :=  sTemp;
        --if ItemDB.FindFirst(Item_Id) = SysOk then
          --g_bUpdate := True;
          --PromptForEntry("Enter Item Name", SetupItemName, ItemDB.Name,0);
        --else
          --g_bUpdate := False;
          --PromptForEntry("Enter Item Name", SetupItemName, Blank,0);
        --end if;
      --end if;

    --elsif EntryMode = SetupItemName then
      --if IsValid(stemp, "s",15) then
        --ItemDB.Name  :=  sTemp;
        --if g_bUpdate = True then
          --PromptForEntry("Enter Item Low Weight", SetupItemLowWeight, RealToString(ItemDB.Low,0,g_iDecimal1),2);
        --else
          --PromptForEntry("Enter Item Low Weight", SetupItemLowWeight, Blank,2);
        --end if;
      --end if;

    --elsif EntryMode = SetupItemLowWeight then
      --if IsValid(stemp, "r", 1) then
        --ItemDB.Low := StringToReal(sTemp);  
        --if g_bUpdate = True then
          --PromptForEntry("Enter Item High Weight", SetupItemHighWeight, RealToString(ItemDB.High,0,g_iDecimal1),2);
        --else
          --PromptForEntry("Enter Item High Weight", SetupItemHighWeight, Blank,2);
        --end if;       
      --end if;   

    --elsif EntryMode = SetupItemHighWeight then
      --if IsValid(stemp, "r", 1 ) then 
        --if StringToReal(sTemp) > ItemDB.Low then
          --ItemDB.High := StringToReal(sTemp);  
          --if g_bUpdate = True then
            --if ItemDB.Update = SysOk then
              --DisplayStatus("Item Updated");
            --else 
              --DisplayStatus("Error: Item DB");
            --end if;
						-- If Item selected was updated were updating screen
						--if ItemDB.Id = g_sItemId then 
        			--g_sItemId := ItemDB.Id;    
        			--g_sItemName := ItemDB.Name;
        			--g_rLowWeight := ItemDB.Low;
        			--g_rHighWeight := ItemDB.High;  
              --g_rLastSavedWgt := 0;  
        			--RefreshMainDisplay;   
        			--SetLabelText(lbSts1, Blank);  	
						--end if;						
          --else
            --if ItemDB.Add = SysOk then
              --DisplayStatus("Item Added");
            --else 
              --DisplayStatus("Error: Item DB");
            --end if;
          --end if; 				
          --EntryMode := Setup1Mode;      
        --else
          --PromptForEntry("Error High < Low", SetupItemHighWeight, Blank,2);
        --end if; 
      --end if;       

    --elsif EntryMode = SetupDeleteItem then
      --ItemDB.Id := sTemp;
      --if ItemDB.FindFirst(Item_Id) = SysOk then
        --if ItemDB.Delete = SysOk then    
          --DisplayStatus("Item Deleted"); 
        --else  
          --DisplayStatus("Error: Item DB");
        --end if;
				
				-- If Item selected was updated were updating screen
				--if ItemDB.Id = g_sItemId then 
        	--g_sItemId := Blank;    
        	--g_sItemName := Blank;
        	--g_rLowWeight := 0.0;
        	--g_rHighWeight := 0.0;   
          --g_rLastSavedWgt := 0; 
        	--RefreshMainDisplay;   
        	--SetLabelText(lbSts1, Blank);  	
				--end if;	
				
      --else
        --DisplayStatus("ID NOT FOUND");
      --end if;
      --EntryMode := Setup1Mode;

    --elsif EntryMode = EnterItemID then

      --if g_bWeighVault = True then
        --if StringToInteger(sTemp) <= 9999 then
          --SendDatatoPC("GET_ID|" + sTemp); 
        --else
          --PromptForEntry("WeighVault Accepts (1-9999) - Retry", EnterItemID, Blank,0);   
        --end if;
      --else
        --ItemDB.Id := sTemp;
        
        --if ItemDB.FindFirst(Item_Id) = SysOk then
          --g_sItemId := ItemDB.Id;    
          --g_sItemName := ItemDB.Name;
          --g_rLowWeight := ItemDB.Low;
          --g_rHighWeight := ItemDB.High;   
          --g_rLastSavedWgt := 0; 
          --RefreshMainDisplay;   
          --SetLabelText(lbSts1, Blank);   
          --EntryMode := NoMode;
        --else
          --PromptForEntry("ID NOT Found - Retry", EnterItemID, Blank,0); 
        --end if; 
      --end if;
			
		--elsif EntryMode = SetupClearTransactions then
			
			--if sTemp = "Y" then
				--if TransDB.Clear = SysOk then
				 	--DisplayStatus("Transactions Database Cleared");
				--else
					--DisplayStatus("Error Clearing Transaction Database");
				--end if;
			--else
				--DisplayStatus("Transaction Database NOT Cleared");
			--end if;
			--EntryMode := Setup1Mode;
   
    --end if; 

    --if EntryMode >=  Setup1Mode then
      --RefreshSetupDisplay;
    --end if; 
          
  --end; 


--I JUST GOT RID OF THIS STEPHEN 
-- attempt to add 
  procedure ProcessTempOrders;
  begin
    --x := g_iBags;
    
    --for i = 1 to x
    --loop
    OrdersDB.num := g_iNums; 
    OrdersDB.itemID := g_sItemId;
    OrdersDB.lotNum := g_sItemLot;
    OrdersDB.weight := g_rItemWeight;
    OrdersDB.orderNum := g_sOrderNum; 


      g_sysResult := OrdersDB.FindFirst(Orders_num); --This will equal SysOk if found in DB
      if g_sysResult <> SysOk then
        OrdersDB.Add;
      end if;

  end;

-- extract
  procedure ExtractTempOrders;
  x : integer;
  i : integer;
  begin
    x := g_iBags;
    
    for i := 1 to x
    loop
      OrdersDB.num := i; 
      OrdersDB.itemID := g_sItemId;
      OrdersDB.lotNum := g_sItemLot;
      OrdersDB.weight := g_rItemWeight;
      OrdersDB.orderNum := g_sOrderNum; 

      g_sysResult := OrdersDB.FindFirst(Orders_num); --This will equal SysOk if found in DB
      if g_sysResult <> SysOk then
        OrdersDB.Add;
      end if;
    end loop;
  end;
  

  procedure ProcessPromptCancel;   -- Performs Cancel operation when cancelling a prompt
    begin 
    
      ClosePrompt;  

      if g_Entrymode = UserIdMode then 
        EntryMode := LoginMode;
        g_sUserId := Blank;
        SetLabelText(lbl18, Blank);
        SelectScreen(g_ciMainLogin);
      elsif g_EntryMode = PasswordMode then
        EntryMode := LoginMode;
        g_sPassword := Blank;
        SetLabelText(lbl19, Blank);
        SelectScreen(g_ciMainLogin);
      elsif g_EntryMode = SetOrderNumMode then
        EntryMode := OrderMode;
        g_sOrderNum := Blank;
        SetLabelText(lbl38, Blank);
        SelectScreen(g_ciOrderNum);
      elsif g_EntryMode = NewUserMode then
        EntryMode := SetupMenuMode;
        g_sTUser := Blank;
        SetLabelText(lbl18, Blank);
        SelectScreen(g_ciMainLogin);
      elsif g_EntryMode = NewPasswordMode then
        EntryMode := SetupMenuMode;
        g_sTPass := Blank;
        SetLabelText(lbl19, Blank);
        SelectScreen(g_ciMainLogin);
      else    
        EntryMode := NoMode;  
      end if;


      

    end; 
 

  procedure ProcessDataEntry(sTemp : string); --Processes different data entries based on the entry mode the program is in
  i : integer;
  begin
    --This is only going to show up for OPERATOR ENTRY
    if g_Entrymode = UserIdMode then 
      if sTemp = Blank then
        PromptForEntry("Invalid User ID - Retry", UserIdMode, Blank, 1);
      end if;
      g_sUserId := sTemp;
      SetLabelText(lbl18, g_sUserId);
      EntryMode := LoginMode; 

    elsif g_EntryMode = PasswordMode then
      if sTemp = Blank then
        PromptForEntry("Invalid Password Entry - Retry", PasswordMode, Blank, 1); 
      end if;
      locked := False;
      --g_sPassword := sTemp;
      --SetLabelText(lbl19, g_sPassword);
      for i := 1 to Len(sTemp)
		  loop
			  g_sPassword := g_sPassword + "*";
		  end loop;  
      SetLabelText(lbl19, g_sPassword);
      EntryMode := LoginMode;
      
    elsif g_EntryMode = NewUserMode then
      if sTemp = Blank then
        PromptForEntry("Invalid User ID - Retry", NewUserMode, Blank, 0);
      end if;
      g_sTUser := sTemp;
      SetLabelText(lbl24, g_sTUser);
      EntryMode := ProcessNewUser;

    
    elsif g_EntryMode = NewPasswordMode then
      if sTemp = Blank then
        PromptForEntry("Invalid Password Entry - Retry", NewPasswordMode, Blank, 1);
      end if;
      g_sTPass := sTemp;
      SetLabelText(lbl25, g_sTPass);
      EntryMode := ProcessNewUser;
      if FileExists("/sdimages/adduser.png", SDCard) = SysOk then  
        SetImageWidgetPath(AddUser, "/adduser.png");
        SetWidgetVisibility(AddUser, Von);
      end if;
    
    elsif g_EntryMode = AdminPasswordMode then
      if sTemp = g_ciBackDoorPassword then
        locked := false;
        EntryMode := SetupMenuMode;
        SelectScreen(g_ciSetUpUsers);
        SetWidgetVisibility(AddUser, Voff);
      else
        PromptForEntry("INVALID Please Enter Admin Password", AdminPasswordMode, Blank, 1);
      end if;
      
    elsif g_EntryMode = SetOrderNumMode then
      if sTemp = Blank then
        PromptForEntry("INVALID Order Entry", SetOrderNumMode, Blank, 0);
      end if;
      g_sOrderNum := sTemp;
      SetLabelText(lbl38, g_sOrderNum);
    
    elsif g_EntryMode = GetBagsMode then
    if sTemp = Blank then
      PromptForEntry("INVALID Entry", GetBagsMode, Blank, 2);
    end if;
    g_iBags := StringToInteger(sTemp);
      
    elsif g_EntryMode = ScannedItemMode then
      g_sItemId := Left$(g_sScannerInput,9);
      g_sTempScanned := Right$(g_sScannerInput, Len(g_sScannerInput)-10);
      GetLotandWeight(g_sTempScanned);
      processingWeight;


      --WriteLn(2, g_sTempScanned);
      -- we take the value from the barcode, anything before the decimal place is displayed 
      -- as pounds and after the decimal place it gets calculated as ounces
      -- we are displaying the target weight, pounds and ounces
      -- when we are counting the final total we are printing in pounds






    --elsif g_EntryMode = EnterPurchaseOrderMode then 
      --if sTemp = Blank then 
        --PromptForEntry("Invalid: To Continue Enter Purchase Order", EnterPurchaseOrderMode, Blank, 1);
      --end if;
      --t_purchase := sTemp;
      --EntryMode := ProductSelectMode;
      --if FileExists("/sdimages/next.png", SDCard) = SysOk then
        --SetImageWidgetPath(btnNxt, "/next.png");
      --else
        --SetImageWidgetPath(btnNxt, "local://10.png");
      --end if;
      --SetWidgetVisibility(btnNxt, Voff);
      --ResetProduct;
      --FillProductArray;
      --SelectScreen(g_ciProduct);      
    end if;
  end;


--REVISE TO PORT 1
  handler Port1CharReceived;  -- Scanner
  begin 
    
    if EntryMode = ScanMode then

       if EventChar = Chr$(13) then -- this means if eventchar = carriage return then
               
         --WriteLn(g_ciDebug, "Raw Scanner Input: ", "     ", g_sScannerInput);
         --g_sScannerInput :=  Right$(g_sScannerInput, Len(g_sScannerInput) - 5);
         --WriteLn(g_ciDebug, "Cropped Scanner Input: ", "     ", g_sScannerInput);  
         --EntryMode := ScannedItemMode;
         --SetKeys; --look into this, do we need it?
         
         --g_sScannerInput := ;

         EntryMode := ScannedItemMode;
         g_EntryMode := ScannedItemMode;
         SetLabelText(lbl31,g_sScannerInput);
         ProcessDataEntry(g_sScannerInput);
         g_sScannerInput := Blank;               
                          
       else  
         
         g_sScannerInput := g_sScannerInput + EventChar;  
         --DisplayStatus(g_sScannerInput);  
        
       end if;  
       
    end if;
         
  end;   


  procedure Ready;  -- Initialization procedure
  begin
    
    UnLockMajorKeys;
    --SetLabelText(lbSts1, Blank);    
		--SetLabelText(lbAOU, Blank);
    
    if GetUnits(CurrentScale, g_uUnits) = SysOk then
      if GetCountBy(CurrentScale, g_uUnits, g_rCountby) = SysOk then
        g_iDecimal1 := CalcDecimal(g_rCountby); 
      end if;
    end if;           
	
    --SetupScreens;
    SelectScreen(g_ciMainLogin);  
    SetSPValue(1, g_rThresholdWeight);
    SetSPValue(2, g_rThresholdWeight);
		EnableSP(1);
    EntryMode := NoMode;
    RefreshMainDisplay;
  end;        

  handler Timer1Trip; -- Attempt to tare
  begin
    
    g_iTareAttempt := g_iTareAttempt + 1; 
    if g_iTareAttempt < 15 then 
      if SetTare(CurrentScale, g_uUnits, g_rTareWgt) = SysOk then 
        SetMode(CurrentScale, NetMode);                           
        StopTimer(1);
      end if;
    else 
      StopTimer(1); 
      DisplayStatus("Error Taring Scale");
    end if; 
            
  end;    

   
  
  handler Timer25Trip;  -- Wait for Standstill check
    iMotion : integer;   
    rNetWgt : real;
		iInRange : integer;
    rTareWgt : real;
  begin 

    -- Make sure Item selected
    if g_sItemId = Blank then  
      return;
    end if;		 

    InMotion(CurrentScale, iMotion);
    GetUnits(CurrentScale, g_uUnits);
    g_sysResult1 := GetNet(CurrentScale, g_uUnits, rNetWgt); 
    g_sysResult2 := InRange(CurrentScale, iInRange);   
    GetTare(CurrentScale, g_uUnits, g_rTareWgt);

    -- Get Net Command   I JUST GOT RID OF THIS STEPHEN
    if g_sysResult1 <> SysOk then
      SetLabelText(lbSts1, "Scale Error: " + SysCodeToString(g_sysResult1)); 
      --TurnOffAllOutputs;
      --TurnOffWidgets; 
      return;
    end if;
--    
    -- Check In Range
    if g_sysResult2 <> SysOk then
      SetLabelText(lbSts1, "Scale Error: " + SysCodeToString(g_sysResult2));  
      --TurnOffAllOutputs;
      --TurnOffWidgets;
      return;
    end if;			
    
    -- Validate InRage
    if iInRange = 0 then  
      SetLabelText(lbSts1, "Scale NOT In Range");  
      --TurnOffAllOutputs;
      --TurnOffWidgets;
      return;
    end if;  

    if EntryMode = NoMode then  
      return;
    end if;
    
    if rNetWgt < g_rItemWeight then                       
      SetLabelText(lbAOU, "UNDER");
      SetWidgetColor(lbAOU, "Orange"); 
      setwidgetColor(1, "Orange");

    elsif rNetWgt > g_rItemWeight then 
      SetLabelText(lbAOU, "OVER");
      SetWidgetColor(lbAOU, "Red");
      setwidgetColor(1, "Red");	

    else
      SetLabelText(lbAOU, "ACCEPTED");
      SetWidgetColor(lbAOU, "Green");
      setwidgetColor(1, "Green"); 	
    end if;


    if iMotion = 0 and EntryMode = ProductOnScale then    
      DisplayStatus(Blank);  
      SetLabelText(lbSts1,  Blank);  
                        
      if rNetWgt < g_rItemWeight then                       
        SetLabelText(lbAOU, "UNDER");
				SetWidgetColor(lbAOU, "Orange"); 
				--TransDB.Status := "U";
        setwidgetColor(1, "Orange");
        g_rLastSavedWgt := rNetWgt;

      elsif rNetWgt > g_rItemWeight then
        SetLabelText(lbAOU, "OVER");
				SetWidgetColor(lbAOU, "Red"); 
				--TransDB.Status := "O";	
        setwidgetColor(1, "Red");	
        g_rLastSavedWgt := rNetWgt;

      else
        SetLabelText(lbAOU, "ACCEPTED");
				SetWidgetColor(lbAOU, "Green");
        setwidgetColor(1, "Green"); 	
				--TransDB.Status := "A";	
        g_rLastSavedWgt := rNetWgt;
      end if; 

      SetLabelText(lbSts1, "Last Stable Weight - " + Realtostring(g_rLastSavedWgt,0,g_iDecimal1));

      if g_bPrintPressed = True then
        StopTimer(25);
        --StoreorSendTransaction(g_rLastSavedWgt);
        PrintTicket;
      end if;


		end if; 
 
  end;       

  handler SP1Trip; -- Item Above Threshold
    sUnits : string;
  begin 

    DisableSP(1); 
    GetUnits(CurrentScale, g_uUnits);
    GetUnitsString(CurrentScale, g_uUnits, sUnits);
    --SetWidgetVisibility(setup, Voff);
    g_bPrintPressed := False;
    if g_bWeighVault = True then
      if UCase$(sUnits) = UCase$(g_sUnits) then  
        EntryMode := ProductOnScale;
        SetupStartTimer(25, 5, TimerContinuous); 
      --else
        --SetLabelText(lbSts1, "Unit Configuration Mis-Match");
      end if;
    else
      EntryMode := ProductOnScale;
      SetupStartTimer(25, 5, TimerContinuous); 
    end if;
    EnableSP(2);
    
  end;  

  handler SP2Trip; -- Item Dropped below Threshold
  begin

    DisableSP(2);
    EntryMode := NoMode;
    StopTimer(25);  
    --SetLabelText(lbSts1, Blank);
		--TurnOffAllOutputs;
    TurnOffWidgets;
    --SetWidgetVisibility(setup, Von);

    --if g_bPrintPressed = False then
      --if g_rLastSavedWgt <> 0 then
        --if g_rLastSavedWgt < g_rLowWeight then                       
          --TransDB.Status := "U";
        --elsif g_rLastSavedWgt > g_rHighWeight then
          --TransDB.Status := "O";		     
        --else
          --TransDB.Status := "A";	       		
        --end if; 
        --StoreorSendTransaction(g_rLastSavedWgt);
        --if g_iAutoPrint = 1 then
          --PrintTicket;
        --end if; 
      --end if;
    --end if;

    EnableSP(1);
 
  end;   

  handler PrintKeyPressed;
  begin

    if EntryMode = ProductOnScale and g_bPrintPressed = False then  
      g_bPrintPressed := True;
    end if;

  end;

  handler Timer29Trip;  -- Removes display status text  
  begin 
 
    DisplayStatus(Blank);     
    
  end;    

  handler UserEntry;  -- Processing a data entry method
    sTemp : string;  
  begin   
  
    sTemp := GetEntry; 
    
    if EventKey = EnterKey then     --Enter key pressed
      ProcessDataEntry(sTemp); 
    else                            --Cancel key pressed    
      ProcessPromptCancel;    
    end if;

  end;  

	handler UnitsKeyReleased;  -- Just incase secondary units is on (let't refresh decimal and screen)
	begin
    if GetUnits(CurrentScale, g_uUnits) = SysOk then
      if GetCountBy(CurrentScale, g_uUnits, g_rCountby) = SysOk then
        g_iDecimal1 := CalcDecimal(g_rCountby); 
      end if;
    end if;   	
		RefreshMainDisplay;
	end;

 handler WidgetClicked;
  begin

  	DisableHandler(WidgetClicked);
		g_iWidget := EventWidget;
		DisplayStatus("");

    --if g_iWidget = lbSet1 or g_iWidget = lbSet11 then
			--PromptForEntry("Enter New Password", SetupChangePasswordMode, Blank,0); 
    --elsif g_iWidget = lbSet2 or g_iWidget = lbSet22 then
      --PromptForEntry("Enter Threshold Weight", SetupThresholdWeight, RealToString(g_rThresholdWeight, 0, g_iDecimal1),2);  
    --elsif g_iWidget = lbSet3 then
		  --if g_iAutoPrint = 1 then
        --g_iAutoPrint := 0;
      --else        
        --g_iAutoPrint := 1;
      --end if;
      --RefreshSetupDisplay;      
    --elsif g_iWidget = lbSet4 then 
		  --Setlabeltext(lbl116,"Clear Transaction Database?");
      --EntryMode := SetupClearTransactions;
      --SelectSCreen(5);
    --elsif g_iWidget = lbSet5 then 
      ---PromptForEntry("Enter Item Id", SetupItemId, Blank,0);
    --elsif g_iWidget = lbSet6 then
      --PromptForEntry("Enter Item Id", SetupDeleteItem, Blank,0);        
    --elsif g_iWidget = lbSet7 then 
      --KeyPress(DatabaseKey);
    --elsif g_iWidget = lbSet8 or g_iWidget = lbSet88 then 	  
      --if g_bWeighVault = True then
        --g_bWeighVault := False;    
      --else
        --g_bWeighVault := True;    
      --end if;
      --g_sItemId := Blank;    
      --g_sItemName := Blank;
      --g_rLowWeight := 0.0;
      --g_rHighWeight := 0.0; 
      --g_rLastSavedWgt := 0;
      --RefreshMainDisplay;         
      --RefreshSetupDisplay;       
    --elsif g_iWidget = lbSet9 or g_iWidget = lbSet99 then
      --SendDataToPC("TEST");        
    --elsif g_iWidget = lbUnder or g_iWidget = sym36 then
      --ToggleOutput(g_coUnder);
    --elsif g_iWidget = lbAccept or g_iWidget = sym70 then
      --ToggleOutput(g_coAccept);
    --elsif g_iWidget = lbOver or g_iWidget = sym83 then
      --ToggleOutput(g_coOver);
    --elsif g_iWidget = lbID1 then
      --PromptForEntry("Enter ID to Checkweigh", EnterItemID, Blank,0); 
    
    --elsif g_iWidget = Setup then 

      --if EntryMode = noMode then        
        -- Bypassing password entry if zero or blank
        --if g_sSetupPassword = "0" or g_sSetupPassword = Blank then
          --GoIntoSetupMenu;           
        --else       
          --PromptForEntry("Enter Password", SetupEnterPasswordMode, Blank, 1);
        --end if; 
      --end if;

    if g_iWidget = btnSetup then
      PromptForEntry("Enter Admin Password to Create New User", AdminPasswordMode, Blank,1); 

    elsif g_iWidget = lbl18 then
      PromptForEntry("Enter User ID", UserIdMode, Blank, 0);

    elsif g_iWidget = lbl19 then
      PromptForEntry("Enter Password", PasswordMode, Blank, 1);

    elsif g_iWidget = btnLogin then
      ProcessingLoginEntry;

    elsif g_iWidget = lbl24 then
      PromptForEntry("Enter New User ID", NewUserMode, Blank, 0);

    elsif g_iWidget = lbl25 then
      PromptForEntry("Enter New Password", NewPasswordMode, Blank, 0);
    
    elsif g_iWidget = AddUser then
      AddNewUser;

    elsif g_iWidget = Ext5 then
      g_sOrderNum := Blank;
      SetLabelText(lbl38, Blank);
      EntryMode := NoMode;
      SelectScreen(g_ciMainLogin);

    elsif g_iWidget = Nxt2 then
     -- test : string;
      EntryMode := StatusMode;
      SelectScreen(g_ciStatus);
      --targetweight := RealToString(g_rItemWeight, 1, 2);
      SetLabelText(lbl13, g_sItemWeight);
      SetLabelText(lbl10, g_sItemId);
      SetLabelText(lbl52, g_sItemLot);
      SetLabelText(lbl6, g_sPounds + "lbs" + " " + g_sOunces + "oz");
    elsif g_iWidget = Ext2 then
      EntryMode := OrderMode;
      SetLabelText(38, Blank);
      g_sOrderNum := Blank;
      SelectScreen(g_ciOrderNum);

    elsif g_iWidget = lbl38 then
      PromptForEntry("Enter Order Number", SetOrderNumMode, Blank, 0);
    
    elsif g_iWidget = Nxt6 then
      EntryMode := ScanMode;
      SelectScreen(g_ciScanBar);

    elsif g_iWidget = Ext6 then
      EntryMode := NoMode;
      ClearWidgetsLogin;
      ClearLoginUser;
      SelectScreen(g_ciMainLogin);

    elsif g_iWidget = Ext3 then
      EntryMode := ScanMode;
      SetLabelText(lbl31, Blank);
      g_sScannerInput := Blank;
      SelectScreen(g_ciScanBar);
    
    elsif g_iWidget = Ext7 then
      Selectscreen(g_ciScanBar);
    
    elsif g_iWidget = lbl48 then
      PromptForEntry("Enter the amount of bags for this batch", GetBagsMode, Blank, 0);

    
    --elsif g_iWidget = lbl31 then
      --Port1CharReceived;
    --elsif g_iWidget = lbYes then
      --EntryMode := SetupClearTransactions;
      --SelectScreen(g_cisetup);
      --ProcessDataEntry("Y");  

    --elsif g_iWidget = lbNo then
      --EntryMode := SetupClearTransactions;
      --SelectScreen(g_ciSetup);
      --ProcessDataEntry("N");  
    --elsif g_iWidget = Exit8 then
      --TurnOffAllOutputs;
      --SelectScreen(g_ciMainLogin);
      --EntryMode := NoMode;
      --SetLabelText(lbPC, Blank); 
			--DisplayStatus(Blank);
			--EnableSP(1);
    end if;

    EnableHandler(WidgetClicked);
    
  
  end;


begin
  
  --DisableSetPoints; 
  DisplayVersion; 
  setmenubarcolor("Black");

  if g_iDownload = 0 then
    g_iDownload := 1;
    g_sSetupPassword := Blank; 
    g_rThresholdWeight := 10;
    g_iAutoPrint := 1;
    g_bWeighVault := False;
  end if;    
  g_sScannerInput := Blank;
  Ready;


end Colorite; 
